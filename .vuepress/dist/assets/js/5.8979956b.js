(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{171:function(e,t,a){"use strict";a.r(t);var i=a(0),r=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"software-engineering-principle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#software-engineering-principle","aria-hidden":"true"}},[e._v("#")]),e._v(" Software Engineering Principle")]),e._v(" "),a("h2",{attrs:{id:"equivalence-partitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#equivalence-partitions","aria-hidden":"true"}},[e._v("#")]),e._v(" Equivalence partitions")]),e._v(" "),a("ul",[a("li",[e._v("Break values into three ranges.")]),e._v(" "),a("li",[e._v("Minimum: the range which is very low and rarely encountered.")]),e._v(" "),a("li",[e._v("Mid: the range which is encountered very often.")]),e._v(" "),a("li",[e._v("Maximum: the range which is very low and rarely encountered.")])]),e._v(" "),a("h2",{attrs:{id:"search-routine-specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#search-routine-specification","aria-hidden":"true"}},[e._v("#")]),e._v(" Search routine specification")]),e._v(" "),a("p",[e._v("Test cases can be derive base on the partitioning technique.")]),e._v(" "),a("h3",{attrs:{id:"define"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#define","aria-hidden":"true"}},[e._v("#")]),e._v(" Define")]),e._v(" "),a("ul",[a("li",[e._v("Pre-condition")]),e._v(" "),a("li",[e._v("Post-condition")]),e._v(" "),a("li",[e._v("Additional conditions")])]),e._v(" "),a("h2",{attrs:{id:"structural-testing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#structural-testing","aria-hidden":"true"}},[e._v("#")]),e._v(" Structural testing")]),e._v(" "),a("ul",[a("li",[e._v("Sometime called white-box testing.")]),e._v(" "),a("li",[e._v("Derivation of test cases according to program structure. Knowledge of the program\nis used to identify additional test cases.")]),e._v(" "),a("li",[e._v("Objective is to exercise all program statements (not all path combinations).")]),e._v(" "),a("li",[e._v("Try to create the highest coverage of the code.")])]),e._v(" "),a("h2",{attrs:{id:"basic-path-testing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#basic-path-testing","aria-hidden":"true"}},[e._v("#")]),e._v(" Basic Path Testing")]),e._v(" "),a("h3",{attrs:{id:"flow-graph-notation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flow-graph-notation","aria-hidden":"true"}},[e._v("#")]),e._v(" Flow Graph Notation")]),e._v(" "),a("ul",[a("li",[e._v("Convert statements into nodes.")]),e._v(" "),a("li",[a("strong",[e._v("Region")]),e._v(": enclosed-area in the graph.")]),e._v(" "),a("li",[e._v("In defining number of paths, uses the "),a("strong",[e._v("Cyclomatic complexity technique")]),e._v(".")]),e._v(" "),a("li",[e._v("Use the number of regions.")]),e._v(" "),a("li",[a("strong",[e._v("V(G) = E - N + 2")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("E")]),e._v(": Number of edges")]),e._v(" "),a("li",[a("strong",[e._v("N")]),e._v(": Number of nodes")])])]),e._v(" "),a("li",[a("strong",[e._v("V(G) = P + 1")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("P:")]),e._v(" predicate nodes - nodes those leads to more than 2 nodes.")])])]),e._v(" "),a("li",[e._v("Cyclomatic Complexity considers only in the syntactical aspect.")])]),e._v(" "),a("h3",{attrs:{id:"deriving-test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deriving-test-cases","aria-hidden":"true"}},[e._v("#")]),e._v(" Deriving Test Cases")]),e._v(" "),a("ol",[a("li",[e._v("Using the design or code as a foundation, draw a corresponding flow graph.")]),e._v(" "),a("li",[e._v("Determine the cyclomatic complexity of the resultant flow graph.")]),e._v(" "),a("li",[e._v("Determine a basis set of linearly independent paths.")]),e._v(" "),a("li",[e._v("Prepare test cases that will force execution of each path in the basis set.")])]),e._v(" "),a("h1",{attrs:{id:"final-exam-guideline-lecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-exam-guideline-lecture","aria-hidden":"true"}},[e._v("#")]),e._v(" Final Exam Guideline [Lecture]")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Closed-book exam")])])]),e._v(" "),a("h2",{attrs:{id:"final-lecture-exam"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-lecture-exam","aria-hidden":"true"}},[e._v("#")]),e._v(" Final Lecture-exam")]),e._v(" "),a("ul",[a("li",[e._v("Focuses on "),a("strong",[e._v("Object-Oriented Analysis and Design")]),e._v(".\n"),a("ul",[a("li",[a("strong",[e._v("Diagrams")]),e._v(": derives diagrams from requirements\n"),a("ul",[a("li",[e._v("Use-case Diagram")]),e._v(" "),a("li",[e._v("Sequence Diagram")]),e._v(" "),a("li",[e._v("Class Diagram")]),e._v(" "),a("li",[e._v("State-chart Diagram")])])])])]),e._v(" "),a("li",[e._v("Testing.\n"),a("ul",[a("li",[e._v("Testing definitions")]),e._v(" "),a("li",[e._v("Basic Path Testing")])])])]),e._v(" "),a("h2",{attrs:{id:"final-lab-exam-laboratory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#final-lab-exam-laboratory","aria-hidden":"true"}},[e._v("#")]),e._v(" Final Lab-exam [Laboratory]")]),e._v(" "),a("ul",[a("li",[e._v("Basic concept of Python implementation: "),a("strong",[e._v("Polymorphism, Inheritance")])]),e._v(" "),a("li",[e._v("Class Diagrams --\x3e Python Code")]),e._v(" "),a("li",[e._v("Some diagrams.")]),e._v(" "),a("li",[e._v("Chapter 13")])])])}],!1,null,null,null);t.default=r.exports}}]);